/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   color_calculate.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: snikitin <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2018/06/13 12:40:52 by snikitin          #+#    #+#             */
/*   Updated: 2018/07/07 17:53:33 by snikitin         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "rtv1.h"

int		see_the_light(t_vec_3 point, t_light *light, t_object *objects)
{
	t_hit	hit;

	hit = ray_trace((t_ray){point, vec_normalize(light->pos - point)}, objects);
	if (hit.obj &&
			(vec_magnitude(hit.pnt - point) < vec_magnitude(light->pos - point)))
	{
		//printf("%f\n", vec_magnitude(hit.pnt - point));
		return (0);
	}
	return (1);
}

//Uint32		ads_to_rgb(t_vec_3 ambient, t_vec_3 diffuse, t_vec_3 specular)
Uint32		ads_to_rgb(t_vec_3 result)
{
	t_color	clr;

	clr.c_32 = 0;
	clr.c_8[R] = 255.99 * result[R];
	clr.c_8[G] = 255.99 * result[G];
	clr.c_8[B] = 255.99 * result[B];
	return (clr.c_32);
}

Uint32		shade_pixel(t_hit hit, t_light *lights, t_object *objects)
{
	//t_vec_3	normal;

	t_vec_3	ambient;
	t_vec_3	diffuse;
//	t_vec_3	specular;
(void)objects;

	while (lights)
	{
		ambient = hit.obj->ambient * lights->ambient;
		t_vec_3	normal = hit.obj->get_normal(hit.obj, hit.pnt);
		double	dot_p = vec_dot_product(vec_normalize(lights->pos - hit.pnt), normal);
		if (dot_p > 0  && see_the_light(hit.pnt, lights, objects))
			diffuse = vec_mul_scal(hit.obj->diffuse * lights->diffuse, dot_p);
		else
			ft_bzero(&diffuse, sizeof(t_vec_3));
		//if (see_the_light(hit.pnt, lights, objects))
		//{
		//	specular = hit.obj.specular * lights->specular;

		//}
		lights = lights->next;
	}

	//(void) objects;
	//dot_p = vec_dot_product(vec_normalize(lights->pos - hit.pnt), normal);

	//clr.c_32 = hit.obj->color;
	//{
	//}
	//else 
	//	return (0);
	return (ads_to_rgb(ambient + diffuse));// + specular));
}

//Uint32		shade_pixel(t_hit hit, t_light *lights, t_object *objects)
//{
//	t_vec_3	normal;
//	t_color	clr;
//	double dot_p;
//
//
//	(void) objects;
//	normal = hit.obj->get_normal(hit.obj, hit.pnt);
//	dot_p = vec_dot_product(vec_normalize(lights->pos - hit.pnt), normal);
//
//	clr.c_32 = hit.obj->color;
//	//return (clr.c_32);	
//	if (dot_p > 0  && see_the_light(hit.pnt, lights, objects))
//	{
//		clr.c_8[R] *= dot_p;
//		clr.c_8[G] *= dot_p;
//		clr.c_8[B] *= dot_p;
//	}
//	else 
//		return (0);
//	return (clr.c_32);
//}
